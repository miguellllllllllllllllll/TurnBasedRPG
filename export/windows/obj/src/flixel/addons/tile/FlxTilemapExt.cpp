// Generated by Haxe 4.3.6
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_addons_tile_FlxTileAnimation
#include <flixel/addons/tile/FlxTileAnimation.h>
#endif
#ifndef INCLUDED_flixel_addons_tile_FlxTileSpecial
#include <flixel/addons/tile/FlxTileSpecial.h>
#endif
#ifndef INCLUDED_flixel_addons_tile_FlxTilemapExt
#include <flixel/addons/tile/FlxTilemapExt.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxDrawBaseItem
#include <flixel/graphics/tile/FlxDrawBaseItem.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxDrawQuadsItem
#include <flixel/graphics/tile/FlxDrawQuadsItem.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxGraphicsShader
#include <flixel/graphics/tile/FlxGraphicsShader.h>
#endif
#ifndef INCLUDED_flixel_math_FlxBasePoint
#include <flixel/math/FlxBasePoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxBaseTilemap
#include <flixel/tile/FlxBaseTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTile
#include <flixel/tile/FlxTile.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemap
#include <flixel/tile/FlxTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemapBuffer
#include <flixel/tile/FlxTilemapBuffer.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTypedTilemap
#include <flixel/tile/FlxTypedTilemap.h>
#endif
#ifndef INCLUDED_flixel_util_FlxColorTransformUtil
#include <flixel/util/FlxColorTransformUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool
#include <flixel/util/FlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_GraphicsShader
#include <openfl/display/GraphicsShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Point
#include <openfl/geom/Point.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_36_new,"flixel.addons.tile.FlxTilemapExt","new",0xf39da2c0,"flixel.addons.tile.FlxTilemapExt.new","flixel/addons/tile/FlxTilemapExt.hx",36,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_61_destroy,"flixel.addons.tile.FlxTilemapExt","destroy",0x5c98af5a,"flixel.addons.tile.FlxTilemapExt.destroy","flixel/addons/tile/FlxTilemapExt.hx",61,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_81_update,"flixel.addons.tile.FlxTilemapExt","update",0x159f6fa9,"flixel.addons.tile.FlxTilemapExt.update","flixel/addons/tile/FlxTilemapExt.hx",81,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_110_drawTilemap,"flixel.addons.tile.FlxTilemapExt","drawTilemap",0x95ca66ea,"flixel.addons.tile.FlxTilemapExt.drawTilemap","flixel/addons/tile/FlxTilemapExt.hx",110,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_291_setSpecialTiles,"flixel.addons.tile.FlxTilemapExt","setSpecialTiles",0xceebf9ae,"flixel.addons.tile.FlxTilemapExt.setSpecialTiles","flixel/addons/tile/FlxTilemapExt.hx",291,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_339_overlapsWithCallback,"flixel.addons.tile.FlxTilemapExt","overlapsWithCallback",0x527644b7,"flixel.addons.tile.FlxTilemapExt.overlapsWithCallback","flixel/addons/tile/FlxTilemapExt.hx",339,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_439_setDownwardsGlue,"flixel.addons.tile.FlxTilemapExt","setDownwardsGlue",0xcc5aee08,"flixel.addons.tile.FlxTilemapExt.setDownwardsGlue","flixel/addons/tile/FlxTilemapExt.hx",439,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_454_setSlopes,"flixel.addons.tile.FlxTilemapExt","setSlopes",0x172c788a,"flixel.addons.tile.FlxTilemapExt.setSlopes","flixel/addons/tile/FlxTilemapExt.hx",454,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_481_setGentle,"flixel.addons.tile.FlxTilemapExt","setGentle",0x426fecff,"flixel.addons.tile.FlxTilemapExt.setGentle","flixel/addons/tile/FlxTilemapExt.hx",481,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_504_setSteep,"flixel.addons.tile.FlxTilemapExt","setSteep",0x6a626cad,"flixel.addons.tile.FlxTilemapExt.setSteep","flixel/addons/tile/FlxTilemapExt.hx",504,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_528_checkThickGentle,"flixel.addons.tile.FlxTilemapExt","checkThickGentle",0x33400952,"flixel.addons.tile.FlxTilemapExt.checkThickGentle","flixel/addons/tile/FlxTilemapExt.hx",528,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_533_checkThinGentle,"flixel.addons.tile.FlxTilemapExt","checkThinGentle",0xc0dd29de,"flixel.addons.tile.FlxTilemapExt.checkThinGentle","flixel/addons/tile/FlxTilemapExt.hx",533,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_538_checkThickSteep,"flixel.addons.tile.FlxTilemapExt","checkThickSteep",0x02ff7bba,"flixel.addons.tile.FlxTilemapExt.checkThickSteep","flixel/addons/tile/FlxTilemapExt.hx",538,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_543_checkThinSteep,"flixel.addons.tile.FlxTilemapExt","checkThinSteep",0x3870b0ae,"flixel.addons.tile.FlxTilemapExt.checkThinSteep","flixel/addons/tile/FlxTilemapExt.hx",543,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_552_fixSlopePoint,"flixel.addons.tile.FlxTilemapExt","fixSlopePoint",0x4a6df7ba,"flixel.addons.tile.FlxTilemapExt.fixSlopePoint","flixel/addons/tile/FlxTilemapExt.hx",552,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_564_onCollideFloorSlope,"flixel.addons.tile.FlxTilemapExt","onCollideFloorSlope",0xd997f31e,"flixel.addons.tile.FlxTilemapExt.onCollideFloorSlope","flixel/addons/tile/FlxTilemapExt.hx",564,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_590_onCollideCeilSlope,"flixel.addons.tile.FlxTilemapExt","onCollideCeilSlope",0x2272f167,"flixel.addons.tile.FlxTilemapExt.onCollideCeilSlope","flixel/addons/tile/FlxTilemapExt.hx",590,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_613_solveCollisionSlopeNorthwest,"flixel.addons.tile.FlxTilemapExt","solveCollisionSlopeNorthwest",0x6b73d6bc,"flixel.addons.tile.FlxTilemapExt.solveCollisionSlopeNorthwest","flixel/addons/tile/FlxTilemapExt.hx",613,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_685_solveCollisionSlopeNortheast,"flixel.addons.tile.FlxTilemapExt","solveCollisionSlopeNortheast",0x5f8af68a,"flixel.addons.tile.FlxTilemapExt.solveCollisionSlopeNortheast","flixel/addons/tile/FlxTilemapExt.hx",685,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_757_solveCollisionSlopeSouthwest,"flixel.addons.tile.FlxTilemapExt","solveCollisionSlopeSouthwest",0x06eb4804,"flixel.addons.tile.FlxTilemapExt.solveCollisionSlopeSouthwest","flixel/addons/tile/FlxTilemapExt.hx",757,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_813_solveCollisionSlopeSoutheast,"flixel.addons.tile.FlxTilemapExt","solveCollisionSlopeSoutheast",0xfb0267d2,"flixel.addons.tile.FlxTilemapExt.solveCollisionSlopeSoutheast","flixel/addons/tile/FlxTilemapExt.hx",813,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_867_setSlopeProperties,"flixel.addons.tile.FlxTilemapExt","setSlopeProperties",0x29f54d1c,"flixel.addons.tile.FlxTilemapExt.setSlopeProperties","flixel/addons/tile/FlxTilemapExt.hx",867,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_894_checkArrays,"flixel.addons.tile.FlxTilemapExt","checkArrays",0xa0f57e02,"flixel.addons.tile.FlxTilemapExt.checkArrays","flixel/addons/tile/FlxTilemapExt.hx",894,0x29266091)
HX_LOCAL_STACK_FRAME(_hx_pos_fc36390f83f7f1e5_901_set_frames,"flixel.addons.tile.FlxTilemapExt","set_frames",0x6ce9f783,"flixel.addons.tile.FlxTilemapExt.set_frames","flixel/addons/tile/FlxTilemapExt.hx",901,0x29266091)
namespace flixel{
namespace addons{
namespace tile{

void FlxTilemapExt_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_36_new)
HXLINE(  55)		this->_slopeThinSteep = ::Array_obj< int >::__new(0);
HXLINE(  54)		this->_slopeThickSteep = ::Array_obj< int >::__new(0);
HXLINE(  53)		this->_slopeThinGentle = ::Array_obj< int >::__new(0);
HXLINE(  52)		this->_slopeThickGentle = ::Array_obj< int >::__new(0);
HXLINE(  50)		this->_slopeSoutheast = ::Array_obj< int >::__new(0);
HXLINE(  49)		this->_slopeSouthwest = ::Array_obj< int >::__new(0);
HXLINE(  48)		this->_slopeNortheast = ::Array_obj< int >::__new(0);
HXLINE(  47)		this->_slopeNorthwest = ::Array_obj< int >::__new(0);
HXLINE(  45)		this->_slopeSlowDownFactor = ((Float)0);
HXLINE(  42)		this->_downwardsGlue = false;
HXLINE(  41)		 ::flixel::math::FlxBasePoint point = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(  41)		point->_inPool = false;
HXDLIN(  41)		this->_objPoint = point;
HXLINE(  40)		 ::flixel::math::FlxBasePoint point1 = ::flixel::math::FlxBasePoint_obj::pool->get().StaticCast<  ::flixel::math::FlxBasePoint >()->set(( (Float)(0) ),( (Float)(0) ));
HXDLIN(  40)		point1->_inPool = false;
HXDLIN(  40)		this->_slopePoint = point1;
HXLINE(  39)		this->_snapping = 2;
HXLINE(  36)		super::__construct();
            	}

Dynamic FlxTilemapExt_obj::__CreateEmpty() { return new FlxTilemapExt_obj; }

void *FlxTilemapExt_obj::_hx_vtable = 0;

Dynamic FlxTilemapExt_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< FlxTilemapExt_obj > _hx_result = new FlxTilemapExt_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FlxTilemapExt_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x3d6253b5) {
		if (inClassId<=(int)0x37464a20) {
			if (inClassId<=(int)0x1dc5d3c6) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x1dc5d3c6;
			} else {
				return inClassId==(int)0x37464a20;
			}
		} else {
			return inClassId==(int)0x3d6253b5;
		}
	} else {
		if (inClassId<=(int)0x7dab0655) {
			return inClassId==(int)0x7ccf8994 || inClassId==(int)0x7dab0655;
		} else {
			return inClassId==(int)0x7fac4e48;
		}
	}
}

void FlxTilemapExt_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_61_destroy)
HXLINE(  62)		this->_slopePoint = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->_slopePoint)) );
HXLINE(  63)		this->_objPoint = ( ( ::flixel::math::FlxBasePoint)(::flixel::util::FlxDestroyUtil_obj::put(this->_objPoint)) );
HXLINE(  65)		this->_slopeNorthwest = null();
HXLINE(  66)		this->_slopeNortheast = null();
HXLINE(  67)		this->_slopeSouthwest = null();
HXLINE(  68)		this->_slopeSoutheast = null();
HXLINE(  70)		this->_slopeThickGentle = null();
HXLINE(  71)		this->_slopeThinGentle = null();
HXLINE(  72)		this->_slopeThickSteep = null();
HXLINE(  73)		this->_slopeThinSteep = null();
HXLINE(  75)		this->super::destroy();
HXLINE(  77)		this->_specialTiles = ::flixel::util::FlxDestroyUtil_obj::destroyArray(this->_specialTiles);
            	}


void FlxTilemapExt_obj::update(Float elapsed){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_81_update)
HXLINE(  82)		this->super::update(elapsed);
HXLINE(  83)		bool dirty = false;
HXLINE(  85)		bool _hx_tmp;
HXDLIN(  85)		if (::hx::IsNotNull( this->_specialTiles )) {
HXLINE(  85)			_hx_tmp = (this->_specialTiles->length > 0);
            		}
            		else {
HXLINE(  85)			_hx_tmp = false;
            		}
HXDLIN(  85)		if (_hx_tmp) {
HXLINE(  87)			int _g = 0;
HXDLIN(  87)			::Array< ::Dynamic> _g1 = this->_specialTiles;
HXDLIN(  87)			while((_g < _g1->length)){
HXLINE(  87)				 ::flixel::addons::tile::FlxTileSpecial tile = _g1->__get(_g).StaticCast<  ::flixel::addons::tile::FlxTileSpecial >();
HXDLIN(  87)				_g = (_g + 1);
HXLINE(  89)				bool _hx_tmp1;
HXDLIN(  89)				if (::hx::IsNotNull( tile )) {
HXLINE(  89)					_hx_tmp1 = ::hx::IsNotNull( tile->animation );
            				}
            				else {
HXLINE(  89)					_hx_tmp1 = false;
            				}
HXDLIN(  89)				if (_hx_tmp1) {
HXLINE(  91)					tile->update(elapsed);
HXLINE(  92)					if (!(dirty)) {
HXLINE(  92)						dirty = tile->dirty;
            					}
            					else {
HXLINE(  92)						dirty = true;
            					}
            				}
            			}
            		}
HXLINE(  97)		if (dirty) {
HXLINE(  98)			this->setDirty(true);
            		}
            	}


void FlxTilemapExt_obj::drawTilemap( ::flixel::tile::FlxTilemapBuffer buffer, ::flixel::FlxCamera camera){
            	HX_GC_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_110_drawTilemap)
HXLINE( 111)		bool isColored;
HXDLIN( 111)		if ((this->alpha == 1)) {
HXLINE( 111)			isColored = (this->color != 16777215);
            		}
            		else {
HXLINE( 111)			isColored = true;
            		}
HXLINE( 114)		Float drawX = ( (Float)(0) );
HXLINE( 115)		Float drawY = ( (Float)(0) );
HXLINE( 116)		Float scaledWidth = ( (Float)(0) );
HXLINE( 117)		Float scaledHeight = ( (Float)(0) );
HXLINE( 118)		 ::flixel::graphics::tile::FlxDrawQuadsItem drawItem = null();
HXLINE( 120)		 ::flixel::math::FlxMatrix _tileTransformMatrix = null();
HXLINE( 121)		 ::flixel::math::FlxMatrix matrixToUse;
HXLINE( 123)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 125)			buffer->fill(null());
            		}
            		else {
HXLINE( 129)			{
HXLINE( 129)				 ::flixel::math::FlxBasePoint this1 = this->getScreenPosition(this->_point,camera);
HXDLIN( 129)				 ::flixel::math::FlxBasePoint point = this->offset;
HXDLIN( 129)				{
HXLINE( 129)					Float y = point->y;
HXDLIN( 129)					this1->set_x((this1->x - point->x));
HXDLIN( 129)					this1->set_y((this1->y - y));
            				}
HXDLIN( 129)				{
HXLINE( 129)					 ::flixel::math::FlxBasePoint _this = point;
HXDLIN( 129)					if (_this->_weak) {
HXLINE( 129)						_this->put();
            					}
            				}
HXDLIN( 129)				 ::flixel::math::FlxBasePoint this2 = this1;
HXDLIN( 129)				 ::openfl::geom::Point p = this->_helperPoint;
HXDLIN( 129)				if (::hx::IsNull( p )) {
HXLINE( 129)					p =  ::openfl::geom::Point_obj::__alloc( HX_CTX ,null(),null());
            				}
HXDLIN( 129)				p->x = this2->x;
HXDLIN( 129)				p->y = this2->y;
            			}
HXLINE( 131)			Float _hx_tmp;
HXDLIN( 131)			if (this->isPixelPerfectRender(camera)) {
HXLINE( 131)				_hx_tmp = ( (Float)(::Math_obj::floor(this->_helperPoint->x)) );
            			}
            			else {
HXLINE( 131)				_hx_tmp = this->_helperPoint->x;
            			}
HXDLIN( 131)			this->_helperPoint->x = _hx_tmp;
HXLINE( 132)			Float _hx_tmp1;
HXDLIN( 132)			if (this->isPixelPerfectRender(camera)) {
HXLINE( 132)				_hx_tmp1 = ( (Float)(::Math_obj::floor(this->_helperPoint->y)) );
            			}
            			else {
HXLINE( 132)				_hx_tmp1 = this->_helperPoint->y;
            			}
HXDLIN( 132)			this->_helperPoint->y = _hx_tmp1;
HXLINE( 134)			scaledWidth = this->scaledTileWidth;
HXLINE( 135)			scaledHeight = this->scaledTileHeight;
HXLINE( 137)			bool hasColorOffsets;
HXDLIN( 137)			if (::hx::IsNotNull( this->colorTransform )) {
HXLINE( 137)				hasColorOffsets = ::flixel::util::FlxColorTransformUtil_obj::hasRGBAOffsets(this->colorTransform);
            			}
            			else {
HXLINE( 137)				hasColorOffsets = false;
            			}
HXLINE( 138)			drawItem = camera->startQuadBatch(this->graphic,isColored,hasColorOffsets,this->blend,this->antialiasing,this->shader);
            		}
HXLINE( 146)		this->_point->set_x(((((camera->scroll->x * this->scrollFactor->x) - this->x) - this->offset->x) + camera->viewMarginX));
HXLINE( 147)		this->_point->set_y(((((camera->scroll->y * this->scrollFactor->y) - this->y) - this->offset->y) + camera->viewMarginY));
HXLINE( 150)		int screenXInTiles = ::Math_obj::floor((this->_point->x / this->scaledTileWidth));
HXLINE( 151)		int screenYInTiles = ::Math_obj::floor((this->_point->y / this->scaledTileHeight));
HXLINE( 152)		int screenRows = buffer->rows;
HXLINE( 153)		int screenColumns = buffer->columns;
HXLINE( 156)		 ::Dynamic Max = (this->widthInTiles - screenColumns);
HXDLIN( 156)		Float lowerBound;
HXDLIN( 156)		if ((screenXInTiles < 0)) {
HXLINE( 156)			lowerBound = ( (Float)(0) );
            		}
            		else {
HXLINE( 156)			lowerBound = ( (Float)(screenXInTiles) );
            		}
HXDLIN( 156)		Float screenXInTiles1;
HXDLIN( 156)		bool screenXInTiles2;
HXDLIN( 156)		if (::hx::IsNotNull( Max )) {
HXLINE( 156)			screenXInTiles2 = ::hx::IsGreater( lowerBound,Max );
            		}
            		else {
HXLINE( 156)			screenXInTiles2 = false;
            		}
HXDLIN( 156)		if (screenXInTiles2) {
HXLINE( 156)			screenXInTiles1 = ( (Float)(Max) );
            		}
            		else {
HXLINE( 156)			screenXInTiles1 = lowerBound;
            		}
HXDLIN( 156)		screenXInTiles = ::Std_obj::_hx_int(screenXInTiles1);
HXLINE( 157)		 ::Dynamic Max1 = (this->heightInTiles - screenRows);
HXDLIN( 157)		Float lowerBound1;
HXDLIN( 157)		if ((screenYInTiles < 0)) {
HXLINE( 157)			lowerBound1 = ( (Float)(0) );
            		}
            		else {
HXLINE( 157)			lowerBound1 = ( (Float)(screenYInTiles) );
            		}
HXDLIN( 157)		Float screenYInTiles1;
HXDLIN( 157)		bool screenYInTiles2;
HXDLIN( 157)		if (::hx::IsNotNull( Max1 )) {
HXLINE( 157)			screenYInTiles2 = ::hx::IsGreater( lowerBound1,Max1 );
            		}
            		else {
HXLINE( 157)			screenYInTiles2 = false;
            		}
HXDLIN( 157)		if (screenYInTiles2) {
HXLINE( 157)			screenYInTiles1 = ( (Float)(Max1) );
            		}
            		else {
HXLINE( 157)			screenYInTiles1 = lowerBound1;
            		}
HXDLIN( 157)		screenYInTiles = ::Std_obj::_hx_int(screenYInTiles1);
HXLINE( 159)		int rowIndex = ((screenYInTiles * this->widthInTiles) + screenXInTiles);
HXLINE( 160)		this->_flashPoint->y = ( (Float)(0) );
HXLINE( 161)		int columnIndex;
HXLINE( 162)		 ::flixel::tile::FlxTile tile;
HXLINE( 163)		 ::flixel::graphics::frames::FlxFrame frame;
HXLINE( 164)		 ::flixel::addons::tile::FlxTileSpecial special;
HXLINE( 170)		bool isSpecial = false;
HXLINE( 172)		{
HXLINE( 172)			int _g = 0;
HXDLIN( 172)			int _g1 = screenRows;
HXDLIN( 172)			while((_g < _g1)){
HXLINE( 172)				_g = (_g + 1);
HXDLIN( 172)				int row = (_g - 1);
HXLINE( 174)				columnIndex = rowIndex;
HXLINE( 175)				this->_flashPoint->x = ( (Float)(0) );
HXLINE( 177)				{
HXLINE( 177)					int _g2 = 0;
HXDLIN( 177)					int _g3 = screenColumns;
HXDLIN( 177)					while((_g2 < _g3)){
HXLINE( 177)						_g2 = (_g2 + 1);
HXDLIN( 177)						int column = (_g2 - 1);
HXLINE( 179)						tile = Dynamic( this->_tileObjects->__get(this->_data->__get(columnIndex))).StaticCast<  ::flixel::tile::FlxTile >();
HXLINE( 180)						special = null();
HXLINE( 181)						isSpecial = false;
HXLINE( 183)						bool _hx_tmp2;
HXDLIN( 183)						if (::hx::IsNotNull( this->_specialTiles )) {
HXLINE( 183)							_hx_tmp2 = ::hx::IsNotNull( this->_specialTiles->__get(columnIndex).StaticCast<  ::flixel::addons::tile::FlxTileSpecial >() );
            						}
            						else {
HXLINE( 183)							_hx_tmp2 = false;
            						}
HXDLIN( 183)						if (_hx_tmp2) {
HXLINE( 185)							special = this->_specialTiles->__get(columnIndex).StaticCast<  ::flixel::addons::tile::FlxTileSpecial >();
HXLINE( 186)							bool isSpecial1;
HXDLIN( 186)							bool isSpecial2;
HXDLIN( 186)							if (!(special->flipX)) {
HXLINE( 186)								isSpecial2 = special->flipY;
            							}
            							else {
HXLINE( 186)								isSpecial2 = true;
            							}
HXDLIN( 186)							if (!(isSpecial2)) {
HXLINE( 186)								isSpecial1 = (special->rotate != 0);
            							}
            							else {
HXLINE( 186)								isSpecial1 = true;
            							}
HXDLIN( 186)							if (!(isSpecial1)) {
HXLINE( 186)								isSpecial = ::hx::IsNotNull( special->animation );
            							}
            							else {
HXLINE( 186)								isSpecial = true;
            							}
            						}
HXLINE( 189)						if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 191)							if (isSpecial) {
HXLINE( 193)								special->paint(buffer->pixels,this->_flashPoint);
HXLINE( 194)								bool _hx_tmp3;
HXDLIN( 194)								if (!(special->dirty)) {
HXLINE( 194)									_hx_tmp3 = buffer->dirty;
            								}
            								else {
HXLINE( 194)									_hx_tmp3 = true;
            								}
HXDLIN( 194)								buffer->dirty = _hx_tmp3;
            							}
            							else {
HXLINE( 196)								bool _hx_tmp4;
HXDLIN( 196)								bool _hx_tmp5;
HXDLIN( 196)								if (::hx::IsNotNull( tile )) {
HXLINE( 196)									_hx_tmp5 = tile->visible;
            								}
            								else {
HXLINE( 196)									_hx_tmp5 = false;
            								}
HXDLIN( 196)								if (_hx_tmp5) {
HXLINE( 196)									_hx_tmp4 = (tile->frame->type != 2);
            								}
            								else {
HXLINE( 196)									_hx_tmp4 = false;
            								}
HXDLIN( 196)								if (_hx_tmp4) {
HXLINE( 198)									tile->frame->paint(buffer->pixels,this->_flashPoint,true,null());
            								}
            							}
            						}
            						else {
HXLINE( 228)							if (isSpecial) {
HXLINE( 228)								frame = special->currFrame;
            							}
            							else {
HXLINE( 228)								frame = tile->frame;
            							}
HXLINE( 230)							if (::hx::IsNotNull( frame )) {
HXLINE( 232)								drawX = (this->_helperPoint->x + (( (Float)(::hx::Mod(columnIndex,this->widthInTiles)) ) * scaledWidth));
HXLINE( 233)								drawY = (this->_helperPoint->y + (( (Float)(::Math_obj::floor((( (Float)(columnIndex) ) / ( (Float)(this->widthInTiles) )))) ) * scaledHeight));
HXLINE( 235)								this->_matrix->identity();
HXLINE( 237)								if (isSpecial) {
HXLINE( 239)									_tileTransformMatrix = special->getMatrix();
HXLINE( 240)									matrixToUse = _tileTransformMatrix;
            								}
            								else {
HXLINE( 244)									frame->prepareMatrix(this->_matrix,null(),null(),null());
HXLINE( 245)									matrixToUse = this->_matrix;
            								}
HXLINE( 248)								Float scaleX = this->scale->x;
HXLINE( 249)								Float scaleY = this->scale->y;
HXLINE( 251)								matrixToUse->scale(scaleX,scaleY);
HXLINE( 252)								matrixToUse->translate(drawX,drawY);
HXLINE( 253)								camera->drawPixels(frame,null(),matrixToUse,this->colorTransform,this->blend,null(),null());
HXLINE( 255)								drawItem->addQuad(frame,matrixToUse,this->colorTransform);
            							}
            						}
HXLINE( 259)						if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 261)							 ::openfl::geom::Point fh = this->_flashPoint;
HXDLIN( 261)							fh->x = (fh->x + this->tileWidth);
            						}
HXLINE( 263)						columnIndex = (columnIndex + 1);
            					}
            				}
HXLINE( 266)				if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 268)					 ::openfl::geom::Point fh1 = this->_flashPoint;
HXDLIN( 268)					fh1->y = (fh1->y + this->tileHeight);
            				}
HXLINE( 270)				rowIndex = (rowIndex + this->widthInTiles);
            			}
            		}
HXLINE( 273)		buffer->x = (( (Float)(screenXInTiles) ) * this->scaledTileWidth);
HXLINE( 274)		buffer->y = (( (Float)(screenYInTiles) ) * this->scaledTileHeight);
HXLINE( 276)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 278)			if (isColored) {
HXLINE( 279)				buffer->colorTransform(this->colorTransform);
            			}
HXLINE( 280)			buffer->blend = this->blend;
            		}
HXLINE( 283)		buffer->dirty = false;
            	}


void FlxTilemapExt_obj::setSpecialTiles(::Array< ::Dynamic> tiles){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_291_setSpecialTiles)
HXLINE( 292)		this->_specialTiles = ::Array_obj< ::Dynamic>::__new();
HXLINE( 294)		 ::flixel::addons::tile::FlxTileSpecial tile;
HXLINE( 295)		{
HXLINE( 295)			int _g = 0;
HXDLIN( 295)			int _g1 = tiles->length;
HXDLIN( 295)			while((_g < _g1)){
HXLINE( 295)				_g = (_g + 1);
HXDLIN( 295)				int i = (_g - 1);
HXLINE( 297)				tile = tiles->__get(i).StaticCast<  ::flixel::addons::tile::FlxTileSpecial >();
HXLINE( 298)				bool _hx_tmp;
HXDLIN( 298)				if (::hx::IsNotNull( tile )) {
HXLINE( 298)					bool _hx_tmp1;
HXDLIN( 298)					bool _hx_tmp2;
HXDLIN( 298)					if (!(tile->flipX)) {
HXLINE( 298)						_hx_tmp2 = tile->flipY;
            					}
            					else {
HXLINE( 298)						_hx_tmp2 = true;
            					}
HXDLIN( 298)					if (!(_hx_tmp2)) {
HXLINE( 298)						_hx_tmp1 = (tile->rotate != 0);
            					}
            					else {
HXLINE( 298)						_hx_tmp1 = true;
            					}
HXDLIN( 298)					if (!(_hx_tmp1)) {
HXLINE( 298)						_hx_tmp = ::hx::IsNotNull( tile->animation );
            					}
            					else {
HXLINE( 298)						_hx_tmp = true;
            					}
            				}
            				else {
HXLINE( 298)					_hx_tmp = false;
            				}
HXDLIN( 298)				if (_hx_tmp) {
HXLINE( 300)					this->_specialTiles[i] = tile;
HXLINE( 302)					tile->set_currTileId((tile->currTileId - this->_startingIndex));
HXLINE( 303)					tile->set_frames(this->frames);
HXLINE( 305)					if (::hx::IsNotNull( tile->animation )) {
HXLINE( 307)						::Array< int > animFrames = tile->animation->frames;
HXLINE( 308)						::Array< int > preparedFrames = ::Array_obj< int >::__new(0);
HXLINE( 310)						{
HXLINE( 310)							int _g2 = 0;
HXDLIN( 310)							int _g3 = animFrames->length;
HXDLIN( 310)							while((_g2 < _g3)){
HXLINE( 310)								_g2 = (_g2 + 1);
HXDLIN( 310)								int j = (_g2 - 1);
HXLINE( 312)								preparedFrames[j] = (animFrames->__get(j) - this->_startingIndex);
            							}
            						}
HXLINE( 315)						tile->animation->frames = preparedFrames;
            					}
            				}
            				else {
HXLINE( 320)					this->_specialTiles[i] = null();
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,setSpecialTiles,(void))

bool FlxTilemapExt_obj::overlapsWithCallback( ::flixel::FlxObject object, ::Dynamic callback,::hx::Null< bool >  __o_flipCallbackParams, ::flixel::math::FlxBasePoint position){
            		bool flipCallbackParams = __o_flipCallbackParams.Default(false);
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_339_overlapsWithCallback)
HXLINE( 340)		bool results = false;
HXLINE( 342)		Float xPos = this->x;
HXLINE( 343)		Float yPos = this->y;
HXLINE( 345)		if (::hx::IsNotNull( position )) {
HXLINE( 347)			xPos = position->x;
HXLINE( 348)			yPos = position->y;
HXLINE( 349)			{
HXLINE( 349)				 ::flixel::math::FlxBasePoint _this = position;
HXDLIN( 349)				if (_this->_weak) {
HXLINE( 349)					_this->put();
            				}
            			}
            		}
HXLINE( 358)		int value = ::Math_obj::floor(((object->x - xPos) / this->scaledTileWidth));
HXDLIN( 358)		int max = this->widthInTiles;
HXDLIN( 358)		Float lowerBound;
HXDLIN( 358)		if ((value < 0)) {
HXLINE( 358)			lowerBound = ( (Float)(0) );
            		}
            		else {
HXLINE( 358)			lowerBound = ( (Float)(value) );
            		}
HXDLIN( 358)		Float minTileX;
HXDLIN( 358)		bool minTileX1;
HXDLIN( 358)		if (::hx::IsNotNull( max )) {
HXLINE( 358)			minTileX1 = (lowerBound > max);
            		}
            		else {
HXLINE( 358)			minTileX1 = false;
            		}
HXDLIN( 358)		if (minTileX1) {
HXLINE( 358)			minTileX = ( (Float)(max) );
            		}
            		else {
HXLINE( 358)			minTileX = lowerBound;
            		}
HXDLIN( 358)		int minTileX2 = ::Std_obj::_hx_int(minTileX);
HXLINE( 359)		int value1 = ::Math_obj::floor(((object->y - yPos) / this->scaledTileHeight));
HXDLIN( 359)		int max1 = this->heightInTiles;
HXDLIN( 359)		Float lowerBound1;
HXDLIN( 359)		if ((value1 < 0)) {
HXLINE( 359)			lowerBound1 = ( (Float)(0) );
            		}
            		else {
HXLINE( 359)			lowerBound1 = ( (Float)(value1) );
            		}
HXDLIN( 359)		Float minTileY;
HXDLIN( 359)		bool minTileY1;
HXDLIN( 359)		if (::hx::IsNotNull( max1 )) {
HXLINE( 359)			minTileY1 = (lowerBound1 > max1);
            		}
            		else {
HXLINE( 359)			minTileY1 = false;
            		}
HXDLIN( 359)		if (minTileY1) {
HXLINE( 359)			minTileY = ( (Float)(max1) );
            		}
            		else {
HXLINE( 359)			minTileY = lowerBound1;
            		}
HXDLIN( 359)		int minTileY2 = ::Std_obj::_hx_int(minTileY);
HXLINE( 360)		Float object1 = object->x;
HXDLIN( 360)		Float value2 = ((object1 + object->get_width()) - xPos);
HXDLIN( 360)		int value3 = ::Math_obj::ceil((value2 / this->scaledTileWidth));
HXDLIN( 360)		int max2 = this->widthInTiles;
HXDLIN( 360)		Float lowerBound2;
HXDLIN( 360)		if ((value3 < 0)) {
HXLINE( 360)			lowerBound2 = ( (Float)(0) );
            		}
            		else {
HXLINE( 360)			lowerBound2 = ( (Float)(value3) );
            		}
HXDLIN( 360)		Float maxTileX;
HXDLIN( 360)		bool maxTileX1;
HXDLIN( 360)		if (::hx::IsNotNull( max2 )) {
HXLINE( 360)			maxTileX1 = (lowerBound2 > max2);
            		}
            		else {
HXLINE( 360)			maxTileX1 = false;
            		}
HXDLIN( 360)		if (maxTileX1) {
HXLINE( 360)			maxTileX = ( (Float)(max2) );
            		}
            		else {
HXLINE( 360)			maxTileX = lowerBound2;
            		}
HXDLIN( 360)		int maxTileX2 = ::Std_obj::_hx_int(maxTileX);
HXLINE( 361)		Float object2 = object->y;
HXDLIN( 361)		Float value4 = ((object2 + object->get_height()) - yPos);
HXDLIN( 361)		int value5 = ::Math_obj::ceil((value4 / this->scaledTileHeight));
HXDLIN( 361)		int max3 = this->heightInTiles;
HXDLIN( 361)		Float lowerBound3;
HXDLIN( 361)		if ((value5 < 0)) {
HXLINE( 361)			lowerBound3 = ( (Float)(0) );
            		}
            		else {
HXLINE( 361)			lowerBound3 = ( (Float)(value5) );
            		}
HXDLIN( 361)		Float maxTileY;
HXDLIN( 361)		bool maxTileY1;
HXDLIN( 361)		if (::hx::IsNotNull( max3 )) {
HXLINE( 361)			maxTileY1 = (lowerBound3 > max3);
            		}
            		else {
HXLINE( 361)			maxTileY1 = false;
            		}
HXDLIN( 361)		if (maxTileY1) {
HXLINE( 361)			maxTileY = ( (Float)(max3) );
            		}
            		else {
HXLINE( 361)			maxTileY = lowerBound3;
            		}
HXDLIN( 361)		int maxTileY2 = ::Std_obj::_hx_int(maxTileY);
HXLINE( 364)		Float deltaX = (xPos - this->last->x);
HXLINE( 365)		Float deltaY = (yPos - this->last->y);
HXLINE( 368)		{
HXLINE( 368)			int _g = minTileY2;
HXDLIN( 368)			int _g1 = maxTileY2;
HXDLIN( 368)			while((_g < _g1)){
HXLINE( 368)				_g = (_g + 1);
HXDLIN( 368)				int row = (_g - 1);
HXLINE( 370)				{
HXLINE( 370)					int _g2 = minTileX2;
HXDLIN( 370)					int _g3 = maxTileX2;
HXDLIN( 370)					while((_g2 < _g3)){
HXLINE( 370)						_g2 = (_g2 + 1);
HXDLIN( 370)						int column = (_g2 - 1);
HXLINE( 372)						int mapIndex = ((row * this->widthInTiles) + column);
HXLINE( 373)						int dataIndex = this->_data->__get(mapIndex);
HXLINE( 374)						if ((dataIndex < 0)) {
HXLINE( 375)							continue;
            						}
HXLINE( 377)						 ::flixel::tile::FlxTile tile = Dynamic( this->_tileObjects->__get(dataIndex)).StaticCast<  ::flixel::tile::FlxTile >();
HXLINE( 379)						if ((tile->allowCollisions != 0)) {
HXLINE( 381)							bool overlapFound = false;
HXLINE( 383)							tile->set_width(this->scaledTileWidth);
HXLINE( 384)							tile->set_height(this->scaledTileHeight);
HXLINE( 385)							tile->set_x((xPos + (( (Float)(column) ) * tile->get_width())));
HXLINE( 386)							tile->set_y((yPos + (( (Float)(row) ) * tile->get_height())));
HXLINE( 387)							tile->last->set_x((tile->x - deltaX));
HXLINE( 388)							tile->last->set_y((tile->y - deltaY));
HXLINE( 390)							if (::hx::IsNotNull( callback )) {
HXLINE( 392)								if (flipCallbackParams) {
HXLINE( 394)									overlapFound = ( (bool)(callback(object,tile)) );
            								}
            								else {
HXLINE( 398)									overlapFound = ( (bool)(callback(tile,object)) );
            								}
            							}
            							else {
HXLINE( 403)								bool overlapFound1;
HXDLIN( 403)								bool overlapFound2;
HXDLIN( 403)								Float object3 = object->x;
HXDLIN( 403)								Float overlapFound3 = (object3 + object->get_width());
HXDLIN( 403)								if ((overlapFound3 > tile->x)) {
HXLINE( 403)									Float object4 = object->x;
HXDLIN( 403)									Float tile1 = tile->x;
HXDLIN( 403)									overlapFound2 = (object4 < (tile1 + tile->get_width()));
            								}
            								else {
HXLINE( 403)									overlapFound2 = false;
            								}
HXDLIN( 403)								if (overlapFound2) {
HXLINE( 403)									Float object5 = object->y;
HXDLIN( 403)									Float overlapFound4 = (object5 + object->get_height());
HXDLIN( 403)									overlapFound1 = (overlapFound4 > tile->y);
            								}
            								else {
HXLINE( 403)									overlapFound1 = false;
            								}
HXDLIN( 403)								if (overlapFound1) {
HXLINE( 404)									Float object6 = object->y;
HXDLIN( 404)									Float tile2 = tile->y;
HXDLIN( 404)									overlapFound = (object6 < (tile2 + tile->get_height()));
            								}
            								else {
HXLINE( 403)									overlapFound = false;
            								}
            							}
HXLINE( 408)							bool _hx_tmp;
HXDLIN( 408)							if (!(overlapFound)) {
HXLINE( 408)								if (!(overlapFound)) {
HXLINE( 408)									_hx_tmp = this->checkArrays(tile->index);
            								}
            								else {
HXLINE( 408)									_hx_tmp = false;
            								}
            							}
            							else {
HXLINE( 408)								_hx_tmp = true;
            							}
HXDLIN( 408)							if (_hx_tmp) {
HXLINE( 410)								bool _hx_tmp1;
HXDLIN( 410)								if (::hx::IsNotNull( tile->callbackFunction )) {
HXLINE( 410)									if (::hx::IsNotNull( tile->filter )) {
HXLINE( 410)										_hx_tmp1 = ::Std_obj::isOfType(object,tile->filter);
            									}
            									else {
HXLINE( 410)										_hx_tmp1 = true;
            									}
            								}
            								else {
HXLINE( 410)									_hx_tmp1 = false;
            								}
HXDLIN( 410)								if (_hx_tmp1) {
HXLINE( 412)									tile->mapIndex = mapIndex;
HXLINE( 413)									tile->callbackFunction(tile,object);
            								}
HXLINE( 415)								results = true;
            							}
            						}
            						else {
HXLINE( 418)							bool _hx_tmp2;
HXDLIN( 418)							if (::hx::IsNotNull( tile->callbackFunction )) {
HXLINE( 418)								if (::hx::IsNotNull( tile->filter )) {
HXLINE( 418)									_hx_tmp2 = ::Std_obj::isOfType(object,tile->filter);
            								}
            								else {
HXLINE( 418)									_hx_tmp2 = true;
            								}
            							}
            							else {
HXLINE( 418)								_hx_tmp2 = false;
            							}
HXDLIN( 418)							if (_hx_tmp2) {
HXLINE( 420)								tile->mapIndex = mapIndex;
HXLINE( 421)								tile->callbackFunction(tile,object);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 426)		return results;
            	}


void FlxTilemapExt_obj::setDownwardsGlue(bool downwardsGlue,::hx::Null< Float >  __o_slopeSlowDownFactor,::hx::Null< Float >  __o_velocityYDownSlope){
            		Float slopeSlowDownFactor = __o_slopeSlowDownFactor.Default(((Float)0.0));
            		Float velocityYDownSlope = __o_velocityYDownSlope.Default(200);
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_439_setDownwardsGlue)
HXLINE( 440)		this->_downwardsGlue = downwardsGlue;
HXLINE( 441)		this->_slopeSlowDownFactor = (( (Float)(1) ) - (slopeSlowDownFactor / ( (Float)(10) )));
HXLINE( 442)		this->_velocityYDownSlope = velocityYDownSlope;
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxTilemapExt_obj,setDownwardsGlue,(void))

void FlxTilemapExt_obj::setSlopes(::Array< int > northwest,::Array< int > northeast,::Array< int > southwest,::Array< int > southeast){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_454_setSlopes)
HXLINE( 455)		if (::hx::IsNotNull( northwest )) {
HXLINE( 457)			this->_slopeNorthwest = northwest;
            		}
HXLINE( 459)		if (::hx::IsNotNull( northeast )) {
HXLINE( 461)			this->_slopeNortheast = northeast;
            		}
HXLINE( 463)		if (::hx::IsNotNull( southwest )) {
HXLINE( 465)			this->_slopeSouthwest = southwest;
            		}
HXLINE( 467)		if (::hx::IsNotNull( southeast )) {
HXLINE( 469)			this->_slopeSoutheast = southeast;
            		}
HXLINE( 471)		this->setSlopeProperties();
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxTilemapExt_obj,setSlopes,(void))

void FlxTilemapExt_obj::setGentle(::Array< int > thickTiles,::Array< int > thinTiles){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_481_setGentle)
HXLINE( 482)		if (::hx::IsNotNull( thickTiles )) {
HXLINE( 484)			this->_slopeThickGentle = thickTiles;
            		}
HXLINE( 487)		if (::hx::IsNotNull( thinTiles )) {
HXLINE( 489)			this->_slopeThinGentle = thinTiles;
HXLINE( 490)			{
HXLINE( 490)				int _g = 0;
HXDLIN( 490)				::Array< int > _g1 = this->_slopeThinGentle;
HXDLIN( 490)				while((_g < _g1->length)){
HXLINE( 490)					int tile = _g1->__get(_g);
HXDLIN( 490)					_g = (_g + 1);
HXLINE( 492)					 ::flixel::tile::FlxTile _hx_tmp = Dynamic( this->_tileObjects->__get(tile)).StaticCast<  ::flixel::tile::FlxTile >();
HXDLIN( 492)					int _hx_tmp1;
HXDLIN( 492)					bool _hx_tmp2;
HXDLIN( 492)					if ((this->_slopeSouthwest->indexOf(tile,null()) < 0)) {
HXLINE( 492)						_hx_tmp2 = (this->_slopeSoutheast->indexOf(tile,null()) >= 0);
            					}
            					else {
HXLINE( 492)						_hx_tmp2 = true;
            					}
HXDLIN( 492)					if (_hx_tmp2) {
HXLINE( 492)						_hx_tmp1 = 256;
            					}
            					else {
HXLINE( 492)						_hx_tmp1 = 4096;
            					}
HXDLIN( 492)					_hx_tmp->set_allowCollisions(_hx_tmp1);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,setGentle,(void))

void FlxTilemapExt_obj::setSteep(::Array< int > thickTiles,::Array< int > thinTiles){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_504_setSteep)
HXLINE( 505)		if (::hx::IsNotNull( thickTiles )) {
HXLINE( 507)			this->_slopeThickSteep = thickTiles;
            		}
HXLINE( 510)		if (::hx::IsNotNull( thinTiles )) {
HXLINE( 512)			this->_slopeThinSteep = thinTiles;
HXLINE( 513)			{
HXLINE( 513)				int _g = 0;
HXDLIN( 513)				::Array< int > _g1 = this->_slopeThinSteep;
HXDLIN( 513)				while((_g < _g1->length)){
HXLINE( 513)					int tile = _g1->__get(_g);
HXDLIN( 513)					_g = (_g + 1);
HXLINE( 515)					 ::flixel::tile::FlxTile _hx_tmp = Dynamic( this->_tileObjects->__get(tile)).StaticCast<  ::flixel::tile::FlxTile >();
HXDLIN( 515)					int _hx_tmp1;
HXDLIN( 515)					bool _hx_tmp2;
HXDLIN( 515)					if ((this->_slopeSouthwest->indexOf(tile,null()) < 0)) {
HXLINE( 515)						_hx_tmp2 = (this->_slopeNorthwest->indexOf(tile,null()) >= 0);
            					}
            					else {
HXLINE( 515)						_hx_tmp2 = true;
            					}
HXDLIN( 515)					if (_hx_tmp2) {
HXLINE( 515)						_hx_tmp1 = 16;
            					}
            					else {
HXLINE( 515)						_hx_tmp1 = 1;
            					}
HXDLIN( 515)					_hx_tmp->set_allowCollisions(_hx_tmp1);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,setSteep,(void))

bool FlxTilemapExt_obj::checkThickGentle(int tileIndex){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_528_checkThickGentle)
HXDLIN( 528)		return (this->_slopeThickGentle->indexOf(tileIndex,null()) >= 0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,checkThickGentle,return )

bool FlxTilemapExt_obj::checkThinGentle(int tileIndex){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_533_checkThinGentle)
HXDLIN( 533)		return (this->_slopeThinGentle->indexOf(tileIndex,null()) >= 0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,checkThinGentle,return )

bool FlxTilemapExt_obj::checkThickSteep(int tileIndex){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_538_checkThickSteep)
HXDLIN( 538)		return (this->_slopeThickSteep->indexOf(tileIndex,null()) >= 0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,checkThickSteep,return )

bool FlxTilemapExt_obj::checkThinSteep(int tileIndex){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_543_checkThinSteep)
HXDLIN( 543)		return (this->_slopeThinSteep->indexOf(tileIndex,null()) >= 0);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,checkThinSteep,return )

void FlxTilemapExt_obj::fixSlopePoint( ::flixel::tile::FlxTile slope){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_552_fixSlopePoint)
HXLINE( 553)		{
HXLINE( 553)			Float Value = this->_slopePoint->x;
HXDLIN( 553)			 ::Dynamic Min = slope->x;
HXDLIN( 553)			 ::Dynamic Max = (slope->x + this->scaledTileWidth);
HXDLIN( 553)			Float lowerBound;
HXDLIN( 553)			bool lowerBound1;
HXDLIN( 553)			if (::hx::IsNotNull( Min )) {
HXLINE( 553)				lowerBound1 = ::hx::IsLess( Value,Min );
            			}
            			else {
HXLINE( 553)				lowerBound1 = false;
            			}
HXDLIN( 553)			if (lowerBound1) {
HXLINE( 553)				lowerBound = ( (Float)(Min) );
            			}
            			else {
HXLINE( 553)				lowerBound = Value;
            			}
HXDLIN( 553)			Float x;
HXDLIN( 553)			bool x1;
HXDLIN( 553)			if (::hx::IsNotNull( Max )) {
HXLINE( 553)				x1 = ::hx::IsGreater( lowerBound,Max );
            			}
            			else {
HXLINE( 553)				x1 = false;
            			}
HXDLIN( 553)			if (x1) {
HXLINE( 553)				x = ( (Float)(Max) );
            			}
            			else {
HXLINE( 553)				x = lowerBound;
            			}
HXDLIN( 553)			this->_slopePoint->set_x(x);
            		}
HXLINE( 554)		{
HXLINE( 554)			Float Value1 = this->_slopePoint->y;
HXDLIN( 554)			 ::Dynamic Min1 = slope->y;
HXDLIN( 554)			 ::Dynamic Max1 = (slope->y + this->scaledTileHeight);
HXDLIN( 554)			Float lowerBound2;
HXDLIN( 554)			bool lowerBound3;
HXDLIN( 554)			if (::hx::IsNotNull( Min1 )) {
HXLINE( 554)				lowerBound3 = ::hx::IsLess( Value1,Min1 );
            			}
            			else {
HXLINE( 554)				lowerBound3 = false;
            			}
HXDLIN( 554)			if (lowerBound3) {
HXLINE( 554)				lowerBound2 = ( (Float)(Min1) );
            			}
            			else {
HXLINE( 554)				lowerBound2 = Value1;
            			}
HXDLIN( 554)			Float y;
HXDLIN( 554)			bool y1;
HXDLIN( 554)			if (::hx::IsNotNull( Max1 )) {
HXLINE( 554)				y1 = ::hx::IsGreater( lowerBound2,Max1 );
            			}
            			else {
HXLINE( 554)				y1 = false;
            			}
HXDLIN( 554)			if (y1) {
HXLINE( 554)				y = ( (Float)(Max1) );
            			}
            			else {
HXLINE( 554)				y = lowerBound2;
            			}
HXDLIN( 554)			this->_slopePoint->set_y(y);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,fixSlopePoint,(void))

void FlxTilemapExt_obj::onCollideFloorSlope( ::flixel::FlxObject slope, ::flixel::FlxObject object){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_564_onCollideFloorSlope)
HXLINE( 566)		object->touching = 4096;
HXLINE( 569)		if (this->_downwardsGlue) {
HXLINE( 570)			object->velocity->set_y(this->_velocityYDownSlope);
            		}
            		else {
HXLINE( 572)			object->velocity->set_y(::Math_obj::min(object->velocity->y,( (Float)(0) )));
            		}
HXLINE( 575)		Float _hx_tmp = this->_slopePoint->y;
HXDLIN( 575)		object->set_y((_hx_tmp - object->get_height()));
HXLINE( 577)		Float object1 = object->y;
HXDLIN( 577)		Float slope1 = slope->y;
HXDLIN( 577)		if ((object1 < (slope1 - object->get_height()))) {
HXLINE( 579)			Float slope2 = slope->y;
HXDLIN( 579)			object->set_y((slope2 - object->get_height()));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,onCollideFloorSlope,(void))

void FlxTilemapExt_obj::onCollideCeilSlope( ::flixel::FlxObject slope, ::flixel::FlxObject object){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_590_onCollideCeilSlope)
HXLINE( 592)		object->touching = 256;
HXLINE( 595)		object->velocity->set_y(::Math_obj::max(object->velocity->y,( (Float)(0) )));
HXLINE( 598)		object->set_y(this->_slopePoint->y);
HXLINE( 600)		if ((object->y > (slope->y + this->scaledTileHeight))) {
HXLINE( 602)			object->set_y((slope->y + this->scaledTileHeight));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,onCollideCeilSlope,(void))

void FlxTilemapExt_obj::solveCollisionSlopeNorthwest( ::flixel::FlxObject slope, ::flixel::FlxObject object){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_613_solveCollisionSlopeNorthwest)
HXLINE( 614)		Float object1 = object->x;
HXDLIN( 614)		Float _hx_tmp = (object1 + object->get_width());
HXDLIN( 614)		Float slope1 = slope->x;
HXDLIN( 614)		Float _hx_tmp1 = (slope1 + slope->get_width());
HXDLIN( 614)		if ((_hx_tmp > (_hx_tmp1 + this->_snapping))) {
HXLINE( 616)			return;
            		}
HXLINE( 619)		{
HXLINE( 619)			 ::flixel::math::FlxBasePoint this1 = this->_objPoint;
HXDLIN( 619)			Float object2 = object->x;
HXDLIN( 619)			Float x = (object2 + object->get_width());
HXDLIN( 619)			this1->set_x(( (Float)(::Math_obj::floor((x + this->_snapping))) ));
            		}
HXLINE( 620)		{
HXLINE( 620)			 ::flixel::math::FlxBasePoint this2 = this->_objPoint;
HXDLIN( 620)			Float object3 = object->y;
HXDLIN( 620)			this2->set_y(( (Float)(::Math_obj::floor((object3 + object->get_height()))) ));
            		}
HXLINE( 624)		this->_slopePoint->set_x(this->_objPoint->x);
HXLINE( 625)		this->_slopePoint->set_y(((slope->y + this->scaledTileHeight) - (this->_slopePoint->x - slope->x)));
HXLINE( 627)		int tileId = ::hx::TCast<  ::flixel::tile::FlxTile >::cast(slope)->index;
HXLINE( 628)		if (this->checkThinSteep(tileId)) {
HXLINE( 630)			if (((this->_slopePoint->x - slope->x) <= (this->scaledTileWidth / ( (Float)(2) )))) {
HXLINE( 632)				return;
            			}
            			else {
HXLINE( 636)				this->_slopePoint->set_y(((slope->y + (this->scaledTileHeight * (( (Float)(2) ) - ((( (Float)(2) ) * (this->_slopePoint->x - slope->x)) / this->scaledTileWidth)))) + this->_snapping));
HXLINE( 637)				bool _hx_tmp2;
HXDLIN( 637)				if (this->_downwardsGlue) {
HXLINE( 637)					_hx_tmp2 = (object->velocity->x > 0);
            				}
            				else {
HXLINE( 637)					_hx_tmp2 = false;
            				}
HXDLIN( 637)				if (_hx_tmp2) {
HXLINE( 638)					object->velocity->set_x((object->velocity->x * (( (Float)(1) ) - ((( (Float)(1) ) - this->_slopeSlowDownFactor) * ( (Float)(3) )))));
            				}
            			}
            		}
            		else {
HXLINE( 641)			if (this->checkThickSteep(tileId)) {
HXLINE( 643)				this->_slopePoint->set_y(((slope->y + (this->scaledTileHeight * (( (Float)(1) ) - (( (Float)(2) ) * ((this->_slopePoint->x - slope->x) / this->scaledTileWidth))))) + this->_snapping));
HXLINE( 644)				bool _hx_tmp3;
HXDLIN( 644)				if (this->_downwardsGlue) {
HXLINE( 644)					_hx_tmp3 = (object->velocity->x > 0);
            				}
            				else {
HXLINE( 644)					_hx_tmp3 = false;
            				}
HXDLIN( 644)				if (_hx_tmp3) {
HXLINE( 645)					object->velocity->set_x((object->velocity->x * (( (Float)(1) ) - ((( (Float)(1) ) - this->_slopeSlowDownFactor) * ( (Float)(3) )))));
            				}
            			}
            			else {
HXLINE( 647)				if (this->checkThickGentle(tileId)) {
HXLINE( 649)					this->_slopePoint->set_y((slope->y + (((this->scaledTileHeight - this->_slopePoint->x) + slope->x) / ( (Float)(2) ))));
HXLINE( 650)					bool _hx_tmp4;
HXDLIN( 650)					if (this->_downwardsGlue) {
HXLINE( 650)						_hx_tmp4 = (object->velocity->x > 0);
            					}
            					else {
HXLINE( 650)						_hx_tmp4 = false;
            					}
HXDLIN( 650)					if (_hx_tmp4) {
HXLINE( 651)						object->velocity->set_x((object->velocity->x * this->_slopeSlowDownFactor));
            					}
            				}
            				else {
HXLINE( 653)					if (this->checkThinGentle(tileId)) {
HXLINE( 655)						this->_slopePoint->set_y(((slope->y + this->scaledTileHeight) - ((this->_slopePoint->x - slope->x) / ( (Float)(2) ))));
HXLINE( 656)						bool _hx_tmp5;
HXDLIN( 656)						if (this->_downwardsGlue) {
HXLINE( 656)							_hx_tmp5 = (object->velocity->x > 0);
            						}
            						else {
HXLINE( 656)							_hx_tmp5 = false;
            						}
HXDLIN( 656)						if (_hx_tmp5) {
HXLINE( 657)							object->velocity->set_x((object->velocity->x * this->_slopeSlowDownFactor));
            						}
            					}
            					else {
HXLINE( 661)						bool _hx_tmp6;
HXDLIN( 661)						if (this->_downwardsGlue) {
HXLINE( 661)							_hx_tmp6 = (object->velocity->x > 0);
            						}
            						else {
HXLINE( 661)							_hx_tmp6 = false;
            						}
HXDLIN( 661)						if (_hx_tmp6) {
HXLINE( 662)							object->velocity->set_x((object->velocity->x * this->_slopeSlowDownFactor));
            						}
            					}
            				}
            			}
            		}
HXLINE( 665)		this->fixSlopePoint(::hx::TCast<  ::flixel::tile::FlxTile >::cast(slope));
HXLINE( 668)		bool _hx_tmp7;
HXDLIN( 668)		bool _hx_tmp8;
HXDLIN( 668)		bool _hx_tmp9;
HXDLIN( 668)		if ((this->_objPoint->x > (slope->x + this->_snapping))) {
HXLINE( 669)			Float _hx_tmp10 = this->_objPoint->x;
HXDLIN( 669)			Float _hx_tmp11 = (slope->x + this->scaledTileWidth);
HXDLIN( 669)			Float _hx_tmp12 = (_hx_tmp11 + object->get_width());
HXLINE( 668)			_hx_tmp9 = (_hx_tmp10 < (_hx_tmp12 + this->_snapping));
            		}
            		else {
HXLINE( 668)			_hx_tmp9 = false;
            		}
HXDLIN( 668)		if (_hx_tmp9) {
HXLINE( 668)			_hx_tmp8 = (this->_objPoint->y >= this->_slopePoint->y);
            		}
            		else {
HXLINE( 668)			_hx_tmp8 = false;
            		}
HXDLIN( 668)		if (_hx_tmp8) {
HXLINE( 668)			_hx_tmp7 = (this->_objPoint->y <= (slope->y + this->scaledTileHeight));
            		}
            		else {
HXLINE( 668)			_hx_tmp7 = false;
            		}
HXDLIN( 668)		if (_hx_tmp7) {
HXLINE( 674)			this->onCollideFloorSlope(slope,object);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,solveCollisionSlopeNorthwest,(void))

void FlxTilemapExt_obj::solveCollisionSlopeNortheast( ::flixel::FlxObject slope, ::flixel::FlxObject object){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_685_solveCollisionSlopeNortheast)
HXLINE( 686)		if ((object->x < (slope->x - ( (Float)(this->_snapping) )))) {
HXLINE( 688)			return;
            		}
HXLINE( 691)		this->_objPoint->set_x(( (Float)(::Math_obj::floor((object->x - ( (Float)(this->_snapping) )))) ));
HXLINE( 692)		{
HXLINE( 692)			 ::flixel::math::FlxBasePoint this1 = this->_objPoint;
HXDLIN( 692)			Float object1 = object->y;
HXDLIN( 692)			this1->set_y(( (Float)(::Math_obj::floor((object1 + object->get_height()))) ));
            		}
HXLINE( 696)		this->_slopePoint->set_x(this->_objPoint->x);
HXLINE( 697)		this->_slopePoint->set_y(((slope->y + this->scaledTileHeight) - ((slope->x - this->_slopePoint->x) + this->scaledTileWidth)));
HXLINE( 699)		int tileId = ::hx::TCast<  ::flixel::tile::FlxTile >::cast(slope)->index;
HXLINE( 700)		if (this->checkThinSteep(tileId)) {
HXLINE( 702)			if (((this->_slopePoint->x - slope->x) >= (this->scaledTileWidth / ( (Float)(2) )))) {
HXLINE( 704)				return;
            			}
            			else {
HXLINE( 708)				this->_slopePoint->set_y(((slope->y + ((this->scaledTileHeight * ( (Float)(2) )) * ((this->_slopePoint->x - slope->x) / this->scaledTileWidth))) + this->_snapping));
            			}
HXLINE( 710)			bool _hx_tmp;
HXDLIN( 710)			if (this->_downwardsGlue) {
HXLINE( 710)				_hx_tmp = (object->velocity->x < 0);
            			}
            			else {
HXLINE( 710)				_hx_tmp = false;
            			}
HXDLIN( 710)			if (_hx_tmp) {
HXLINE( 711)				object->velocity->set_x((object->velocity->x * (( (Float)(1) ) - ((( (Float)(1) ) - this->_slopeSlowDownFactor) * ( (Float)(3) )))));
            			}
            		}
            		else {
HXLINE( 713)			if (this->checkThickSteep(tileId)) {
HXLINE( 715)				this->_slopePoint->set_y(((slope->y - (this->scaledTileHeight * (1 + (( (Float)(2) ) * ((slope->x - this->_slopePoint->x) / this->scaledTileWidth))))) + this->_snapping));
HXLINE( 716)				bool _hx_tmp1;
HXDLIN( 716)				if (this->_downwardsGlue) {
HXLINE( 716)					_hx_tmp1 = (object->velocity->x < 0);
            				}
            				else {
HXLINE( 716)					_hx_tmp1 = false;
            				}
HXDLIN( 716)				if (_hx_tmp1) {
HXLINE( 717)					object->velocity->set_x((object->velocity->x * (( (Float)(1) ) - ((( (Float)(1) ) - this->_slopeSlowDownFactor) * ( (Float)(3) )))));
            				}
            			}
            			else {
HXLINE( 719)				if (this->checkThickGentle(tileId)) {
HXLINE( 721)					this->_slopePoint->set_y((slope->y + ((((this->scaledTileHeight - slope->x) + this->_slopePoint->x) - this->scaledTileWidth) / ( (Float)(2) ))));
HXLINE( 722)					bool _hx_tmp2;
HXDLIN( 722)					if (this->_downwardsGlue) {
HXLINE( 722)						_hx_tmp2 = (object->velocity->x < 0);
            					}
            					else {
HXLINE( 722)						_hx_tmp2 = false;
            					}
HXDLIN( 722)					if (_hx_tmp2) {
HXLINE( 723)						object->velocity->set_x((object->velocity->x * this->_slopeSlowDownFactor));
            					}
            				}
            				else {
HXLINE( 725)					if (this->checkThinGentle(tileId)) {
HXLINE( 727)						this->_slopePoint->set_y(((slope->y + this->scaledTileHeight) - (((slope->x - this->_slopePoint->x) + this->scaledTileWidth) / ( (Float)(2) ))));
HXLINE( 728)						bool _hx_tmp3;
HXDLIN( 728)						if (this->_downwardsGlue) {
HXLINE( 728)							_hx_tmp3 = (object->velocity->x < 0);
            						}
            						else {
HXLINE( 728)							_hx_tmp3 = false;
            						}
HXDLIN( 728)						if (_hx_tmp3) {
HXLINE( 729)							object->velocity->set_x((object->velocity->x * this->_slopeSlowDownFactor));
            						}
            					}
            					else {
HXLINE( 733)						bool _hx_tmp4;
HXDLIN( 733)						if (this->_downwardsGlue) {
HXLINE( 733)							_hx_tmp4 = (object->velocity->x < 0);
            						}
            						else {
HXLINE( 733)							_hx_tmp4 = false;
            						}
HXDLIN( 733)						if (_hx_tmp4) {
HXLINE( 734)							object->velocity->set_x((object->velocity->x * this->_slopeSlowDownFactor));
            						}
            					}
            				}
            			}
            		}
HXLINE( 737)		this->fixSlopePoint(::hx::TCast<  ::flixel::tile::FlxTile >::cast(slope));
HXLINE( 740)		bool _hx_tmp5;
HXDLIN( 740)		bool _hx_tmp6;
HXDLIN( 740)		bool _hx_tmp7;
HXDLIN( 740)		Float _hx_tmp8 = this->_objPoint->x;
HXDLIN( 740)		Float slope1 = slope->x;
HXDLIN( 740)		Float _hx_tmp9 = (slope1 - object->get_width());
HXDLIN( 740)		if ((_hx_tmp8 > (_hx_tmp9 - ( (Float)(this->_snapping) )))) {
HXLINE( 740)			_hx_tmp7 = (this->_objPoint->x < ((slope->x + this->scaledTileWidth) + this->_snapping));
            		}
            		else {
HXLINE( 740)			_hx_tmp7 = false;
            		}
HXDLIN( 740)		if (_hx_tmp7) {
HXLINE( 740)			_hx_tmp6 = (this->_objPoint->y >= this->_slopePoint->y);
            		}
            		else {
HXLINE( 740)			_hx_tmp6 = false;
            		}
HXDLIN( 740)		if (_hx_tmp6) {
HXLINE( 740)			_hx_tmp5 = (this->_objPoint->y <= (slope->y + this->scaledTileHeight));
            		}
            		else {
HXLINE( 740)			_hx_tmp5 = false;
            		}
HXDLIN( 740)		if (_hx_tmp5) {
HXLINE( 746)			this->onCollideFloorSlope(slope,object);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,solveCollisionSlopeNortheast,(void))

void FlxTilemapExt_obj::solveCollisionSlopeSouthwest( ::flixel::FlxObject slope, ::flixel::FlxObject object){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_757_solveCollisionSlopeSouthwest)
HXLINE( 759)		{
HXLINE( 759)			 ::flixel::math::FlxBasePoint this1 = this->_objPoint;
HXDLIN( 759)			Float object1 = object->x;
HXDLIN( 759)			Float x = (object1 + object->get_width());
HXDLIN( 759)			this1->set_x(( (Float)(::Math_obj::floor((x + this->_snapping))) ));
            		}
HXLINE( 760)		this->_objPoint->set_y(( (Float)(::Math_obj::ceil(object->y)) ));
HXLINE( 764)		this->_slopePoint->set_x(this->_objPoint->x);
HXLINE( 765)		this->_slopePoint->set_y((slope->y + (this->_slopePoint->x - slope->x)));
HXLINE( 767)		int tileId = ::hx::TCast<  ::flixel::tile::FlxTile >::cast(slope)->index;
HXLINE( 768)		if (this->checkThinSteep(tileId)) {
HXLINE( 770)			if (((this->_slopePoint->x - slope->x) <= (this->scaledTileWidth / ( (Float)(2) )))) {
HXLINE( 772)				return;
            			}
            			else {
HXLINE( 776)				this->_slopePoint->set_y(((slope->y - (this->scaledTileHeight * (1 + (( (Float)(2) ) * ((slope->x - this->_slopePoint->x) / this->scaledTileWidth))))) - ( (Float)(this->_snapping) )));
            			}
            		}
            		else {
HXLINE( 779)			if (this->checkThickSteep(tileId)) {
HXLINE( 781)				this->_slopePoint->set_y(((slope->y + ((this->scaledTileHeight * ( (Float)(2) )) * ((this->_slopePoint->x - slope->x) / this->scaledTileWidth))) - ( (Float)(this->_snapping) )));
            			}
            			else {
HXLINE( 783)				if (this->checkThickGentle(tileId)) {
HXLINE( 785)					this->_slopePoint->set_y(((slope->y + this->scaledTileHeight) - (((slope->x - this->_slopePoint->x) + this->scaledTileWidth) / ( (Float)(2) ))));
            				}
            				else {
HXLINE( 787)					if (this->checkThinGentle(tileId)) {
HXLINE( 789)						this->_slopePoint->set_y((slope->y + ((((this->scaledTileHeight - slope->x) + this->_slopePoint->x) - this->scaledTileWidth) / ( (Float)(2) ))));
            					}
            				}
            			}
            		}
HXLINE( 793)		this->fixSlopePoint(::hx::TCast<  ::flixel::tile::FlxTile >::cast(slope));
HXLINE( 796)		bool _hx_tmp;
HXDLIN( 796)		bool _hx_tmp1;
HXDLIN( 796)		bool _hx_tmp2;
HXDLIN( 796)		if ((this->_objPoint->x > (slope->x + this->_snapping))) {
HXLINE( 797)			Float _hx_tmp3 = this->_objPoint->x;
HXDLIN( 797)			Float _hx_tmp4 = (slope->x + this->scaledTileWidth);
HXDLIN( 797)			Float _hx_tmp5 = (_hx_tmp4 + object->get_width());
HXLINE( 796)			_hx_tmp2 = (_hx_tmp3 < (_hx_tmp5 + this->_snapping));
            		}
            		else {
HXLINE( 796)			_hx_tmp2 = false;
            		}
HXDLIN( 796)		if (_hx_tmp2) {
HXLINE( 796)			_hx_tmp1 = (this->_objPoint->y <= this->_slopePoint->y);
            		}
            		else {
HXLINE( 796)			_hx_tmp1 = false;
            		}
HXDLIN( 796)		if (_hx_tmp1) {
HXLINE( 796)			_hx_tmp = (this->_objPoint->y >= slope->y);
            		}
            		else {
HXLINE( 796)			_hx_tmp = false;
            		}
HXDLIN( 796)		if (_hx_tmp) {
HXLINE( 802)			this->onCollideCeilSlope(slope,object);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,solveCollisionSlopeSouthwest,(void))

void FlxTilemapExt_obj::solveCollisionSlopeSoutheast( ::flixel::FlxObject slope, ::flixel::FlxObject object){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_813_solveCollisionSlopeSoutheast)
HXLINE( 815)		this->_objPoint->set_x(( (Float)(::Math_obj::floor((object->x - ( (Float)(this->_snapping) )))) ));
HXLINE( 816)		this->_objPoint->set_y(( (Float)(::Math_obj::ceil(object->y)) ));
HXLINE( 820)		this->_slopePoint->set_x(this->_objPoint->x);
HXLINE( 821)		this->_slopePoint->set_y((slope->y + ((slope->x - this->_slopePoint->x) + this->scaledTileWidth)));
HXLINE( 823)		int tileId = ::hx::TCast<  ::flixel::tile::FlxTile >::cast(slope)->index;
HXLINE( 824)		if (this->checkThinSteep(tileId)) {
HXLINE( 826)			if (((this->_slopePoint->x - slope->x) >= (this->scaledTileWidth / ( (Float)(2) )))) {
HXLINE( 828)				return;
            			}
            			else {
HXLINE( 832)				this->_slopePoint->set_y(((slope->y + (this->scaledTileHeight * (( (Float)(1) ) - (( (Float)(2) ) * ((this->_slopePoint->x - slope->x) / this->scaledTileWidth))))) - ( (Float)(this->_snapping) )));
            			}
            		}
            		else {
HXLINE( 835)			if (this->checkThickSteep(tileId)) {
HXLINE( 837)				this->_slopePoint->set_y(((slope->y + (this->scaledTileHeight * (( (Float)(2) ) - ((( (Float)(2) ) * (this->_slopePoint->x - slope->x)) / this->scaledTileWidth)))) - ( (Float)(this->_snapping) )));
            			}
            			else {
HXLINE( 839)				if (this->checkThickGentle(tileId)) {
HXLINE( 841)					this->_slopePoint->set_y(((slope->y + this->scaledTileHeight) - ((this->_slopePoint->x - slope->x) / ( (Float)(2) ))));
            				}
            				else {
HXLINE( 843)					if (this->checkThinGentle(tileId)) {
HXLINE( 845)						this->_slopePoint->set_y((slope->y + (((this->scaledTileHeight - this->_slopePoint->x) + slope->x) / ( (Float)(2) ))));
            					}
            				}
            			}
            		}
HXLINE( 849)		this->fixSlopePoint(::hx::TCast<  ::flixel::tile::FlxTile >::cast(slope));
HXLINE( 852)		bool _hx_tmp;
HXDLIN( 852)		bool _hx_tmp1;
HXDLIN( 852)		bool _hx_tmp2;
HXDLIN( 852)		Float _hx_tmp3 = this->_objPoint->x;
HXDLIN( 852)		Float slope1 = slope->x;
HXDLIN( 852)		Float _hx_tmp4 = (slope1 - object->get_width());
HXDLIN( 852)		if ((_hx_tmp3 > (_hx_tmp4 - ( (Float)(this->_snapping) )))) {
HXLINE( 852)			_hx_tmp2 = (this->_objPoint->x < ((slope->x + this->scaledTileWidth) + this->_snapping));
            		}
            		else {
HXLINE( 852)			_hx_tmp2 = false;
            		}
HXDLIN( 852)		if (_hx_tmp2) {
HXLINE( 852)			_hx_tmp1 = (this->_objPoint->y <= this->_slopePoint->y);
            		}
            		else {
HXLINE( 852)			_hx_tmp1 = false;
            		}
HXDLIN( 852)		if (_hx_tmp1) {
HXLINE( 852)			_hx_tmp = (this->_objPoint->y >= slope->y);
            		}
            		else {
HXLINE( 852)			_hx_tmp = false;
            		}
HXDLIN( 852)		if (_hx_tmp) {
HXLINE( 858)			this->onCollideCeilSlope(slope,object);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemapExt_obj,solveCollisionSlopeSoutheast,(void))

void FlxTilemapExt_obj::setSlopeProperties(){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_867_setSlopeProperties)
HXLINE( 868)		{
HXLINE( 868)			int _g = 0;
HXDLIN( 868)			::Array< int > _g1 = this->_slopeNorthwest;
HXDLIN( 868)			while((_g < _g1->length)){
HXLINE( 868)				int tile = _g1->__get(_g);
HXDLIN( 868)				_g = (_g + 1);
HXLINE( 870)				this->setTileProperties(tile,(16 | 4096),this->solveCollisionSlopeNorthwest_dyn(),null(),null());
            			}
            		}
HXLINE( 872)		{
HXLINE( 872)			int _g2 = 0;
HXDLIN( 872)			::Array< int > _g3 = this->_slopeNortheast;
HXDLIN( 872)			while((_g2 < _g3->length)){
HXLINE( 872)				int tile1 = _g3->__get(_g2);
HXDLIN( 872)				_g2 = (_g2 + 1);
HXLINE( 874)				this->setTileProperties(tile1,(1 | 4096),this->solveCollisionSlopeNortheast_dyn(),null(),null());
            			}
            		}
HXLINE( 876)		{
HXLINE( 876)			int _g4 = 0;
HXDLIN( 876)			::Array< int > _g5 = this->_slopeSouthwest;
HXDLIN( 876)			while((_g4 < _g5->length)){
HXLINE( 876)				int tile2 = _g5->__get(_g4);
HXDLIN( 876)				_g4 = (_g4 + 1);
HXLINE( 878)				this->setTileProperties(tile2,(16 | 256),this->solveCollisionSlopeSouthwest_dyn(),null(),null());
            			}
            		}
HXLINE( 880)		{
HXLINE( 880)			int _g6 = 0;
HXDLIN( 880)			::Array< int > _g7 = this->_slopeSoutheast;
HXDLIN( 880)			while((_g6 < _g7->length)){
HXLINE( 880)				int tile3 = _g7->__get(_g6);
HXDLIN( 880)				_g6 = (_g6 + 1);
HXLINE( 882)				this->setTileProperties(tile3,(1 | 256),this->solveCollisionSlopeSoutheast_dyn(),null(),null());
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTilemapExt_obj,setSlopeProperties,(void))

bool FlxTilemapExt_obj::checkArrays(int tileIndex){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_894_checkArrays)
HXDLIN( 894)		bool _hx_tmp;
HXDLIN( 894)		bool _hx_tmp1;
HXDLIN( 894)		if ((this->_slopeNorthwest->indexOf(tileIndex,null()) < 0)) {
HXDLIN( 894)			_hx_tmp1 = (this->_slopeNortheast->indexOf(tileIndex,null()) >= 0);
            		}
            		else {
HXDLIN( 894)			_hx_tmp1 = true;
            		}
HXDLIN( 894)		if (!(_hx_tmp1)) {
HXDLIN( 894)			_hx_tmp = (this->_slopeSouthwest->indexOf(tileIndex,null()) >= 0);
            		}
            		else {
HXDLIN( 894)			_hx_tmp = true;
            		}
HXDLIN( 894)		if (!(_hx_tmp)) {
HXLINE( 897)			return (this->_slopeSoutheast->indexOf(tileIndex,null()) >= 0);
            		}
            		else {
HXDLIN( 894)			return true;
            		}
HXDLIN( 894)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemapExt_obj,checkArrays,return )

 ::flixel::graphics::frames::FlxFramesCollection FlxTilemapExt_obj::set_frames( ::flixel::graphics::frames::FlxFramesCollection value){
            	HX_STACKFRAME(&_hx_pos_fc36390f83f7f1e5_901_set_frames)
HXLINE( 902)		this->super::set_frames(value);
HXLINE( 904)		bool _hx_tmp;
HXDLIN( 904)		bool _hx_tmp1;
HXDLIN( 904)		if (::hx::IsNotNull( value )) {
HXLINE( 904)			_hx_tmp1 = ::hx::IsNotNull( this->_specialTiles );
            		}
            		else {
HXLINE( 904)			_hx_tmp1 = false;
            		}
HXDLIN( 904)		if (_hx_tmp1) {
HXLINE( 904)			_hx_tmp = (this->_specialTiles->length > 0);
            		}
            		else {
HXLINE( 904)			_hx_tmp = false;
            		}
HXDLIN( 904)		if (_hx_tmp) {
HXLINE( 906)			int _g = 0;
HXDLIN( 906)			::Array< ::Dynamic> _g1 = this->_specialTiles;
HXDLIN( 906)			while((_g < _g1->length)){
HXLINE( 906)				 ::flixel::addons::tile::FlxTileSpecial tile = _g1->__get(_g).StaticCast<  ::flixel::addons::tile::FlxTileSpecial >();
HXDLIN( 906)				_g = (_g + 1);
HXLINE( 908)				if (::hx::IsNotNull( tile )) {
HXLINE( 910)					tile->set_frames(this->frames);
            				}
            			}
            		}
HXLINE( 915)		return value;
            	}



::hx::ObjectPtr< FlxTilemapExt_obj > FlxTilemapExt_obj::__new() {
	::hx::ObjectPtr< FlxTilemapExt_obj > __this = new FlxTilemapExt_obj();
	__this->__construct();
	return __this;
}

::hx::ObjectPtr< FlxTilemapExt_obj > FlxTilemapExt_obj::__alloc(::hx::Ctx *_hx_ctx) {
	FlxTilemapExt_obj *__this = (FlxTilemapExt_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(FlxTilemapExt_obj), true, "flixel.addons.tile.FlxTilemapExt"));
	*(void **)__this = FlxTilemapExt_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

FlxTilemapExt_obj::FlxTilemapExt_obj()
{
}

void FlxTilemapExt_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxTilemapExt);
	HX_MARK_MEMBER_NAME(_snapping,"_snapping");
	HX_MARK_MEMBER_NAME(_slopePoint,"_slopePoint");
	HX_MARK_MEMBER_NAME(_objPoint,"_objPoint");
	HX_MARK_MEMBER_NAME(_downwardsGlue,"_downwardsGlue");
	HX_MARK_MEMBER_NAME(_velocityYDownSlope,"_velocityYDownSlope");
	HX_MARK_MEMBER_NAME(_slopeSlowDownFactor,"_slopeSlowDownFactor");
	HX_MARK_MEMBER_NAME(_slopeNorthwest,"_slopeNorthwest");
	HX_MARK_MEMBER_NAME(_slopeNortheast,"_slopeNortheast");
	HX_MARK_MEMBER_NAME(_slopeSouthwest,"_slopeSouthwest");
	HX_MARK_MEMBER_NAME(_slopeSoutheast,"_slopeSoutheast");
	HX_MARK_MEMBER_NAME(_slopeThickGentle,"_slopeThickGentle");
	HX_MARK_MEMBER_NAME(_slopeThinGentle,"_slopeThinGentle");
	HX_MARK_MEMBER_NAME(_slopeThickSteep,"_slopeThickSteep");
	HX_MARK_MEMBER_NAME(_slopeThinSteep,"_slopeThinSteep");
	HX_MARK_MEMBER_NAME(_specialTiles,"_specialTiles");
	 ::flixel::tile::FlxTypedTilemap_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxTilemapExt_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_snapping,"_snapping");
	HX_VISIT_MEMBER_NAME(_slopePoint,"_slopePoint");
	HX_VISIT_MEMBER_NAME(_objPoint,"_objPoint");
	HX_VISIT_MEMBER_NAME(_downwardsGlue,"_downwardsGlue");
	HX_VISIT_MEMBER_NAME(_velocityYDownSlope,"_velocityYDownSlope");
	HX_VISIT_MEMBER_NAME(_slopeSlowDownFactor,"_slopeSlowDownFactor");
	HX_VISIT_MEMBER_NAME(_slopeNorthwest,"_slopeNorthwest");
	HX_VISIT_MEMBER_NAME(_slopeNortheast,"_slopeNortheast");
	HX_VISIT_MEMBER_NAME(_slopeSouthwest,"_slopeSouthwest");
	HX_VISIT_MEMBER_NAME(_slopeSoutheast,"_slopeSoutheast");
	HX_VISIT_MEMBER_NAME(_slopeThickGentle,"_slopeThickGentle");
	HX_VISIT_MEMBER_NAME(_slopeThinGentle,"_slopeThinGentle");
	HX_VISIT_MEMBER_NAME(_slopeThickSteep,"_slopeThickSteep");
	HX_VISIT_MEMBER_NAME(_slopeThinSteep,"_slopeThinSteep");
	HX_VISIT_MEMBER_NAME(_specialTiles,"_specialTiles");
	 ::flixel::tile::FlxTypedTilemap_obj::__Visit(HX_VISIT_ARG);
}

::hx::Val FlxTilemapExt_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return ::hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"setSteep") ) { return ::hx::Val( setSteep_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"_snapping") ) { return ::hx::Val( _snapping ); }
		if (HX_FIELD_EQ(inName,"_objPoint") ) { return ::hx::Val( _objPoint ); }
		if (HX_FIELD_EQ(inName,"setSlopes") ) { return ::hx::Val( setSlopes_dyn() ); }
		if (HX_FIELD_EQ(inName,"setGentle") ) { return ::hx::Val( setGentle_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"set_frames") ) { return ::hx::Val( set_frames_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_slopePoint") ) { return ::hx::Val( _slopePoint ); }
		if (HX_FIELD_EQ(inName,"drawTilemap") ) { return ::hx::Val( drawTilemap_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkArrays") ) { return ::hx::Val( checkArrays_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_specialTiles") ) { return ::hx::Val( _specialTiles ); }
		if (HX_FIELD_EQ(inName,"fixSlopePoint") ) { return ::hx::Val( fixSlopePoint_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_downwardsGlue") ) { return ::hx::Val( _downwardsGlue ); }
		if (HX_FIELD_EQ(inName,"checkThinSteep") ) { return ::hx::Val( checkThinSteep_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"_slopeNorthwest") ) { return ::hx::Val( _slopeNorthwest ); }
		if (HX_FIELD_EQ(inName,"_slopeNortheast") ) { return ::hx::Val( _slopeNortheast ); }
		if (HX_FIELD_EQ(inName,"_slopeSouthwest") ) { return ::hx::Val( _slopeSouthwest ); }
		if (HX_FIELD_EQ(inName,"_slopeSoutheast") ) { return ::hx::Val( _slopeSoutheast ); }
		if (HX_FIELD_EQ(inName,"_slopeThinSteep") ) { return ::hx::Val( _slopeThinSteep ); }
		if (HX_FIELD_EQ(inName,"setSpecialTiles") ) { return ::hx::Val( setSpecialTiles_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkThinGentle") ) { return ::hx::Val( checkThinGentle_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkThickSteep") ) { return ::hx::Val( checkThickSteep_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"_slopeThinGentle") ) { return ::hx::Val( _slopeThinGentle ); }
		if (HX_FIELD_EQ(inName,"_slopeThickSteep") ) { return ::hx::Val( _slopeThickSteep ); }
		if (HX_FIELD_EQ(inName,"setDownwardsGlue") ) { return ::hx::Val( setDownwardsGlue_dyn() ); }
		if (HX_FIELD_EQ(inName,"checkThickGentle") ) { return ::hx::Val( checkThickGentle_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"_slopeThickGentle") ) { return ::hx::Val( _slopeThickGentle ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"onCollideCeilSlope") ) { return ::hx::Val( onCollideCeilSlope_dyn() ); }
		if (HX_FIELD_EQ(inName,"setSlopeProperties") ) { return ::hx::Val( setSlopeProperties_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_velocityYDownSlope") ) { return ::hx::Val( _velocityYDownSlope ); }
		if (HX_FIELD_EQ(inName,"onCollideFloorSlope") ) { return ::hx::Val( onCollideFloorSlope_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"_slopeSlowDownFactor") ) { return ::hx::Val( _slopeSlowDownFactor ); }
		if (HX_FIELD_EQ(inName,"overlapsWithCallback") ) { return ::hx::Val( overlapsWithCallback_dyn() ); }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"solveCollisionSlopeNorthwest") ) { return ::hx::Val( solveCollisionSlopeNorthwest_dyn() ); }
		if (HX_FIELD_EQ(inName,"solveCollisionSlopeNortheast") ) { return ::hx::Val( solveCollisionSlopeNortheast_dyn() ); }
		if (HX_FIELD_EQ(inName,"solveCollisionSlopeSouthwest") ) { return ::hx::Val( solveCollisionSlopeSouthwest_dyn() ); }
		if (HX_FIELD_EQ(inName,"solveCollisionSlopeSoutheast") ) { return ::hx::Val( solveCollisionSlopeSoutheast_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

::hx::Val FlxTilemapExt_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"_snapping") ) { _snapping=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_objPoint") ) { _objPoint=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_slopePoint") ) { _slopePoint=inValue.Cast<  ::flixel::math::FlxBasePoint >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_specialTiles") ) { _specialTiles=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"_downwardsGlue") ) { _downwardsGlue=inValue.Cast< bool >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"_slopeNorthwest") ) { _slopeNorthwest=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_slopeNortheast") ) { _slopeNortheast=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_slopeSouthwest") ) { _slopeSouthwest=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_slopeSoutheast") ) { _slopeSoutheast=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_slopeThinSteep") ) { _slopeThinSteep=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"_slopeThinGentle") ) { _slopeThinGentle=inValue.Cast< ::Array< int > >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_slopeThickSteep") ) { _slopeThickSteep=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"_slopeThickGentle") ) { _slopeThickGentle=inValue.Cast< ::Array< int > >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_velocityYDownSlope") ) { _velocityYDownSlope=inValue.Cast< Float >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"_slopeSlowDownFactor") ) { _slopeSlowDownFactor=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FlxTilemapExt_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("_snapping",1b,2d,4f,67));
	outFields->push(HX_("_slopePoint",44,f8,e1,eb));
	outFields->push(HX_("_objPoint",38,4c,3e,bb));
	outFields->push(HX_("_downwardsGlue",ab,15,d0,27));
	outFields->push(HX_("_velocityYDownSlope",4c,ea,f9,4e));
	outFields->push(HX_("_slopeSlowDownFactor",be,e5,ff,c6));
	outFields->push(HX_("_slopeNorthwest",68,65,26,14));
	outFields->push(HX_("_slopeNortheast",36,85,3d,08));
	outFields->push(HX_("_slopeSouthwest",b0,d6,9d,af));
	outFields->push(HX_("_slopeSoutheast",7e,f6,b4,a3));
	outFields->push(HX_("_slopeThickGentle",8e,e6,40,0b));
	outFields->push(HX_("_slopeThinGentle",22,c8,46,c5));
	outFields->push(HX_("_slopeThickSteep",fe,19,69,07));
	outFields->push(HX_("_slopeThinSteep",ea,86,a2,7f));
	outFields->push(HX_("_specialTiles",6b,d7,b8,46));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo FlxTilemapExt_obj_sMemberStorageInfo[] = {
	{::hx::fsInt,(int)offsetof(FlxTilemapExt_obj,_snapping),HX_("_snapping",1b,2d,4f,67)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxTilemapExt_obj,_slopePoint),HX_("_slopePoint",44,f8,e1,eb)},
	{::hx::fsObject /*  ::flixel::math::FlxBasePoint */ ,(int)offsetof(FlxTilemapExt_obj,_objPoint),HX_("_objPoint",38,4c,3e,bb)},
	{::hx::fsBool,(int)offsetof(FlxTilemapExt_obj,_downwardsGlue),HX_("_downwardsGlue",ab,15,d0,27)},
	{::hx::fsFloat,(int)offsetof(FlxTilemapExt_obj,_velocityYDownSlope),HX_("_velocityYDownSlope",4c,ea,f9,4e)},
	{::hx::fsFloat,(int)offsetof(FlxTilemapExt_obj,_slopeSlowDownFactor),HX_("_slopeSlowDownFactor",be,e5,ff,c6)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(FlxTilemapExt_obj,_slopeNorthwest),HX_("_slopeNorthwest",68,65,26,14)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(FlxTilemapExt_obj,_slopeNortheast),HX_("_slopeNortheast",36,85,3d,08)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(FlxTilemapExt_obj,_slopeSouthwest),HX_("_slopeSouthwest",b0,d6,9d,af)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(FlxTilemapExt_obj,_slopeSoutheast),HX_("_slopeSoutheast",7e,f6,b4,a3)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(FlxTilemapExt_obj,_slopeThickGentle),HX_("_slopeThickGentle",8e,e6,40,0b)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(FlxTilemapExt_obj,_slopeThinGentle),HX_("_slopeThinGentle",22,c8,46,c5)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(FlxTilemapExt_obj,_slopeThickSteep),HX_("_slopeThickSteep",fe,19,69,07)},
	{::hx::fsObject /* ::Array< int > */ ,(int)offsetof(FlxTilemapExt_obj,_slopeThinSteep),HX_("_slopeThinSteep",ea,86,a2,7f)},
	{::hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(FlxTilemapExt_obj,_specialTiles),HX_("_specialTiles",6b,d7,b8,46)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo *FlxTilemapExt_obj_sStaticStorageInfo = 0;
#endif

static ::String FlxTilemapExt_obj_sMemberFields[] = {
	HX_("_snapping",1b,2d,4f,67),
	HX_("_slopePoint",44,f8,e1,eb),
	HX_("_objPoint",38,4c,3e,bb),
	HX_("_downwardsGlue",ab,15,d0,27),
	HX_("_velocityYDownSlope",4c,ea,f9,4e),
	HX_("_slopeSlowDownFactor",be,e5,ff,c6),
	HX_("_slopeNorthwest",68,65,26,14),
	HX_("_slopeNortheast",36,85,3d,08),
	HX_("_slopeSouthwest",b0,d6,9d,af),
	HX_("_slopeSoutheast",7e,f6,b4,a3),
	HX_("_slopeThickGentle",8e,e6,40,0b),
	HX_("_slopeThinGentle",22,c8,46,c5),
	HX_("_slopeThickSteep",fe,19,69,07),
	HX_("_slopeThinSteep",ea,86,a2,7f),
	HX_("_specialTiles",6b,d7,b8,46),
	HX_("destroy",fa,2c,86,24),
	HX_("update",09,86,05,87),
	HX_("drawTilemap",8a,34,d7,8e),
	HX_("setSpecialTiles",4e,17,00,83),
	HX_("overlapsWithCallback",17,c3,72,a8),
	HX_("setDownwardsGlue",68,bc,e0,a9),
	HX_("setSlopes",2a,9e,ac,d3),
	HX_("setGentle",9f,12,f0,fe),
	HX_("setSteep",0d,db,42,92),
	HX_("checkThickGentle",b2,d7,c5,10),
	HX_("checkThinGentle",7e,47,f1,74),
	HX_("checkThickSteep",5a,99,13,b7),
	HX_("checkThinSteep",0e,27,64,59),
	HX_("fixSlopePoint",5a,6d,81,3a),
	HX_("onCollideFloorSlope",be,60,9b,e6),
	HX_("onCollideCeilSlope",c7,17,d1,c7),
	HX_("solveCollisionSlopeNorthwest",1c,b5,a5,09),
	HX_("solveCollisionSlopeNortheast",ea,d4,bc,fd),
	HX_("solveCollisionSlopeSouthwest",64,26,1d,a5),
	HX_("solveCollisionSlopeSoutheast",32,46,34,99),
	HX_("setSlopeProperties",7c,73,53,cf),
	HX_("checkArrays",a2,4b,02,9a),
	HX_("set_frames",e3,bd,8a,a0),
	::String(null()) };

::hx::Class FlxTilemapExt_obj::__mClass;

void FlxTilemapExt_obj::__register()
{
	FlxTilemapExt_obj _hx_dummy;
	FlxTilemapExt_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("flixel.addons.tile.FlxTilemapExt",ce,82,6d,e6);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &::hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(FlxTilemapExt_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< FlxTilemapExt_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxTilemapExt_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxTilemapExt_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace flixel
} // end namespace addons
} // end namespace tile
